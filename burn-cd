#!/usr/bin/python -O
# -*- coding: cp1251 -*-
"""
Краткое описание:	удобная оболочка для cdrtools и dvd+rw-tools
Автор:			SmART
Последнее изменение:	25 ноября 2006

"""
import sys, os, stat, getopt, string

# Глобальные переменные {{{
PROG = "burn-cd"

VERSION = \
	"%s version 1.5a\n" \
	"Written by SmART, 2004-2006" % PROG

USAGE = "Usage:  %s [options] <file_or_dir_to_burn> [...]" % PROG

DESCRIPTION = \
	"This is handy frontend for cdrtools/cdrkit and dvd+rw-tools\n" \
	"for easy burning of single & multi session CD/DVD disks."

HELP = \
"""Options:
   -r<ROOT>, --root=<ROOT>    destination dir on the CD (defaults to '/')
   -d<DEV>,  --device=<DEV>   CD-RW device (defaults to '/dev/hdc')
   -s<N>,    --speed=<N>      tell cdrecord to burn CD on specific speed
   -c<XYZ>,  --charset=<XYZ>  charset of the filenames (defaults to LOCALE)
   -z,       --zero           blank RW-media before burning (if needed)
   
   -i, --info		      show drive/media info and exit
   -n, --no-color	      disable colors
   -v, --verbose	      show more information during the process
   -h, --help		      show this help and exit
   --version		      show version of the program and exit
   --debug		      enable debug messages during the process
"""
COLOR_0		= "\033[m"
COLOR_1		= "\033[1m"
COLOR_2		= "\033[0;32m"
COLOR_3		= "\033[1;32m"
COLOR_4		= "\033[0;33m"
COLOR_5		= "\033[1;33m"
COLOR_6		= "\033[0;36m"
COLOR_7		= "\033[1;36m"
COLOR_8		= "\033[1;31m"
COLOR_9		= "\033[1;34m"

OK 		= COLOR_9+'['+COLOR_3+'ok'+COLOR_9+']'+COLOR_0
ASTERISK	= COLOR_3+'*'+COLOR_0

mmc_profiles	= {
	0x0000:	'Reserved',
	0x0001:	'Non-removable Disk',
	0x0002:	'Removable Disk',
	0x0003:	'MO Erasable',
	0x0004:	'MO Write Once',
	0x0005:	'AS-MO',
	
	0x0008:	'CD-ROM',
	0x0009:	'CD-R',
	0x000A:	'CD-RW',
	
	0x0010:	'DVD-ROM',
	0x0011:	'DVD-R sequential recording',
	0x0012:	'DVD-RAM',
	0x0013:	'DVD-RW restricted overwrite',
	0x0014:	'DVD-RW sequential overwrite',
	0x0015:	'DVD-R/DL sequential recording',
	0x0016:	'DVD-R/DL layer jump recording',
	
	0x001A:	'DVD+RW',
	0x001B:	'DVD+R',
	
	0x0020:	'DDCD-ROM',
	0x0021:	'DDCD-R',
	0x0022:	'DDCD-RW',
	
	0x002A:	'DVD+RW/DL',
	0x002B:	'DVD+R/DL',
	
	0x0040:	'BD-ROM',
	0x0041:	'BD-R sequential recording',
	0x0042:	'BD-R random recording',
	0x0043:	'BD-RE',
	
	0x0050:	'HD DVD-ROM',
	0x0051:	'HD DVD-R',
	0x0052:	'HD DVD-RAM',

	0xFFFF:	'No standard Profile'
}

write		= sys.stdout.write
flush		= sys.stdout.flush

root		= '/'
lang		= os.getenv( 'LANG' )
try:	charset = lang.split('.')[1].lower()
except:	charset = None
device		= '/dev/hdc'
speed		= None 
single  	= False
verbose		= False
info		= False
debug		= False
media		= None
dvd 		= False

mkisofs_out	= None
cdrecord_out	= None
isoinfo		= False
growisofs	= False
#}}}

def no_color():	#{{{1
	global	COLOR_0, COLOR_1, COLOR_2, COLOR_3, COLOR_4, \
		COLOR_5, COLOR_6, COLOR_7, COLOR_8, COLOR_9
	
	COLOR_0 = COLOR_1 = COLOR_2 = COLOR_3 = COLOR_4 = \
	COLOR_5 = COLOR_6 = COLOR_7 = COLOR_8 = COLOR_9 = ''
#}}}1
def escape_str( str ):	#{{{1
	#str = str.replace( "\\", "\\\\" )
	str = str.replace( "\"", "\\\"" )
	str = str.replace( "\'", "\\\'" )
	str = str.replace( " ", "\\ " )
	str = str.replace( "=", "\\=" )
	str = str.replace( "(", "\\(" )
	str = str.replace( ")", "\\)" )
	str = str.replace( "[", "\\[" )
	str = str.replace( "]", "\\]" )
	str = str.replace( ";", "\\;" )
	str = str.replace( "&", "\\&" )
	str = str.replace( "|", "\\|" )
	str = str.replace( "\011", "\\\011" )
	str = str.replace( "\012", "\\\012" )
	str = str.replace( "\015", "\\\015" )
	return str
#}}}1
def filter_opts( cmd, valid_opts ):	#{{{
	global debug
	
	cmd = cmd.split()
	new_cmd = []
	for op in cmd:
		if len(op)>1 and op[0] == '-' and op not in valid_opts:
			if debug:
				write( 'stripped:  %s\n' % op )
				flush()
		else:
			new_cmd.append( op )
	return string.join( new_cmd )
#}}}
def get_valid_opts( prog_out ):	#{{{
	valid_opts = []
	for s in prog_out:
		s = s.split( None, 1 )
		if not s:  continue
		s = s[0]
		if s[0] == '-':
			valid_opts += s.split(',')
	return valid_opts
#}}}

def run_cmd( cmd ):	#{{{
	ch_out = os.popen( cmd )
	out = [ s for s in ch_out ]
	exit_code = ch_out.close()

	return out, exit_code
#}}}

def print_debug( s, color=COLOR_4 ):	#{{{
	if not debug:  return
	sys.stdout.write( '%s%s%s\n' % (color, s, COLOR_0) )
#}}}
def print_task( s ):	#{{{
	write( '%s %s%-50s%s' % (ASTERISK, COLOR_1, s, COLOR_0) )
	if debug:  print
#}}}
def print_error( s ):	#{{{
	print COLOR_5+'['+COLOR_8+ s +COLOR_5+']'+COLOR_0
#}}}
def print_key_value( key, val, val_color=COLOR_2 ):	#{{{
	key_str = '%s:' % key
	write(
		'  %s%-16s%s%s%s\n' % \
		( COLOR_6, key_str, val_color, val, COLOR_0 )
	)
#}}}
def print_version( prog, ver ):	#{{{
	if ver:
		val_str = 'version %s' % ver
		val_color = COLOR_2
	else:
		val_str = 'not found'
		val_color = COLOR_4
	print_key_value( prog, val_str, val_color )
#}}}
def print_prog_out( out ):	#{{{
	global debug

	write( '  %s.....\n' % COLOR_8 )
	if not debug:  out = out[-10:]
	for s in out:  write( '  ' + s )
	write( COLOR_0 )
#}}}

def parse_cmd_line():	#{{{
	global	root, lang, charset, device, speed, single, \
		verbose, info, debug, media, dvd

	opts, filenames = [], []
	try:	opts, filenames = getopt.getopt(
			sys.argv[1:], 'vnr:d:hc:is:1',
			[ 'help', 'verbose', 'no-color', 'root=', 'device=',
			  'speed=', 'charset=', 'version', 'info', 'debug',
			  'single' ]
		)
	except getopt.GetoptError:
		print USAGE
		print DESCRIPTION
		print HELP
		sys.exit(1)
	
	for opt, val in opts:
		if opt in ['-h','--help']:
			print USAGE
			print HELP
			sys.exit(0)
		elif opt in ['--version']:
			print VERSION
			sys.exit(0)
		elif opt in ['-v','--verbose']:
			verbose = True
		elif opt in ['--debug']:
			debug = True
			verbose = True
		elif opt in ['-n','--no_color']:
			no_color()
		elif opt in ['-r','--root']:
			root = val
		elif opt in ['-d','--device']:
			device = val
		elif opt in ['-s','--speed']:
			try:	speed = int(val)
			except:	pass
		elif opt in ['-1','--single']:
			single = True
		elif opt in ['-c','--charset']:
			charset = val
		elif opt in ['-i','--info']:
			info = True
			verbose = True
	
	if len(filenames) == 0 and not info:
		print USAGE
		print DESCRIPTION
		print HELP
		sys.exit(2)
	
	root = '/' + escape_str( root ).lstrip('/')
	root = root.rstrip('/')
#}}}
def check_programs():	#{{{
	global mkisofs_out, cdrecord_out, isoinfo, growisofs 

	print_task('Checking programs...')

	cmd = 'mkisofs -version 2>/dev/null && mkisofs -help 2>&1'
	print_debug( cmd )
	flush()
	mkisofs_out, mkisofs_exit_code = run_cmd( cmd )
	
	cmd = '(cdrecord -version 2>/dev/null | head -n1 ) && cdrecord -help 2>&1'
	print_debug( cmd )
	flush()
	cdrecord_out, cdrecord_exit_code = run_cmd( cmd )
	
	cmd = 'isoinfo -version 2>/dev/null'
	print_debug( cmd )
	flush()
	isoinfo_out, isoinfo_exit_code = run_cmd( cmd )
	
	cmd = 'growisofs --version 2>/dev/null | head -n1'
	print_debug( cmd )
	flush()
	growisofs_out, growisofs_exit_code = run_cmd( cmd )
	
	if mkisofs_exit_code == None and cdrecord_exit_code == None:
		print OK
		exit_flag = False
	else:
		print_error('not found')
		exit_flag = True
	
	if verbose:
		# mkisofs
		val_str = None
		if mkisofs_exit_code == None:
			mkisofs_ver = mkisofs_out[0].split(' ',2)[1]
			val_str = mkisofs_ver.split(',',1)[0]
		print_version( 'mkisofs', val_str )
		
		# cdrecord
		val_str = None
		if cdrecord_exit_code == None:
			val_str = cdrecord_out[0].split(' ',2)[1]
		print_version( 'cdrecord', val_str )
		
		# isoinfo
		val_str = None
		if isoinfo_exit_code == None:
			val_str = isoinfo_out[0].split(' ',2)[1]
			isoinfo = True
		print_version( 'isoinfo', val_str )
		
		# growisofs
		val_str = None
		if growisofs_exit_code == None:
			try:
				val_str = growisofs_out[0].split(' ',5)[5]
				val_str = val_str.split(',',1)[0]
				growisofs = True
			except:	pass
		print_version( 'growisofs', val_str )
	
		flush()
		
	if not exit_flag:  return

	if verbose:
		out = mkisofs_out + cdrecord_out
		print_prog_out( out )
		flush()
	sys.exit(1)
#}}}
def check_disk_in_drive():	#{{{
	global cdrecord_valid_opts, media, dvd, device, mmc_profiles

	print_task('Looking for a disk in drive...')
	flush()

	cmd = filter_opts( 'cdrecord dev=%s -load -silent -v 2>&1' % device, cdrecord_valid_opts )
	print_debug( cmd )
	out, exit_code = run_cmd( cmd )
	
	error_str = 'unknown'
	match_wrong_dev = "Cannot open '%s'." % device
	for s in out:
		if match_wrong_dev in s:
			error_str = 'wrong device'
		elif 'Current:' in s:
			media = s.split()[1]
			if mmc_profiles.has_key( media ):
				media = mmc_profiles[ media ]
			if media == 'none':
				media = None
				error_str = 'no disk'
			elif media[:3] == 'DVD':
				dvd = True
	if exit_code == None:
		print OK
		exit_flag = False
	else:
		print_error( error_str )
		exit_flag = True
	
	if verbose:
		print_key_value( 'Device', device )
		for s in out:
			if 'Vendor_info' in s:
				try:
					val_str = s.split( '\'', 2 )[1].strip()
					print_key_value( 'Vendor', val_str )
				except:	pass
			if 'Identifi' in s:
				try:
					val_str = s.split( '\'', 2 )[1].strip()
					print_key_value( 'Model', val_str )
				except:	pass
			if 'Revision' in s:
				try:
					val_str = s.split( '\'', 2 )[1].strip()
					print_key_value( 'Firmware', val_str )
				except:	pass
			if 'Device seems to be' in s:
				try:
					val_str = s.split( ':', 1 )[1].strip()[:-1]
					print_key_value( 'Type', val_str )
				except:	pass
		flush()
	
	if not exit_flag:  return

	if verbose:
		print_prog_out( out )
		flush()
	sys.exit(1)
#}}}
def check_CD_disk():	#{{{
	global media, device, cdrecord_valid_opts
	print_task( 'Checking disk type...' )

	cmd = filter_opts( 'cdrecord dev=%s -msinfo -silent -v 2>&1' % device, cdrecord_valid_opts )
	print_debug( cmd )
	flush()
	out, exit_code = run_cmd( cmd )

	appendable = True
	blank = False
	last_start = new_start = 0
	total_space = free_space = 0
	manufacturer = 'n/a'
	disk_type = media
	atip = False
	max_speed = 0
	for s in out:
		if 'ATIP info from disk' in s:
			atip = True
		elif 'ATIP start of lead out' in s:
			try:	total_space = long( s.split(':',1)[1].strip().split()[0] )
			except:	pass
		elif 'Manufacturer' in s:
			try:	manufacturer = s.split(':',1)[1].strip()
			except:	pass
		elif 'Cannot read session offset' in s:
			blank = True
		elif 'Cannot read first writable address' in s:
			appendable = False
		elif '1T speed high:' in s:
			try:	max_speed = int( s.split()[-1].strip() )
			except:	pass
		
	if appendable:
		print OK
		exit_flag = False
	else:
		if 'RW' in media:
			err_str = 'need to blank'
			out += [ '.....\n',
				 'You need to blank RW-media.\n',
				 'Try to add -z to the options list.\n',
				 'CAUTION: previous information on disk will be lost\n' ]
		else:	err_str = 'not writable'
		print_error( err_str )
		exit_flag = True

	if blank:
		free_space = total_space
		disk_type += ' (blank)'
	elif appendable:
		s = out[-1]
		try:	last_start, new_start = map( long, s.split(',',1) )
		except:	pass
		free_space = total_space - new_start
		disk_type += ' (multisession)'
	elif atip:
		disk_type += ' (fixated)'
	
	if verbose:
		print_key_value( 'Disk', disk_type )
		print_key_value( 'Manufacturer', manufacturer )
		if max_speed:
			print_key_value( 'Maximum speed', max_speed )
		if total_space:
			spc = '%.1f MB' % (total_space/512.0)
			print_key_value( 'Total space', spc )
			spc = '%.1f MB (%u%%)' % ( free_space/512.0, free_space*100.0/total_space+0.5 )
			print_key_value( 'Free space', spc )
		flush()
	
	if not exit_flag:  return

	if verbose:
		print_prog_out( out )
		flush()
	sys.exit(1)
#}}}
def check_DVD_disk():	#{{{
	global media, device, cdrecord_valid_opts
	print_task( 'Checking disk type...' )

	cmd = filter_opts( 'cdrecord dev=%s -atip -silent -v 2>&1' % device, cdrecord_valid_opts )
	print_debug( cmd )
	flush()
	out, exit_code = run_cmd( cmd )

	blank = False
	total_space = free_space = 0
	manufacturer = None
	media_id = None
	#book_type = 'unknown'
	disk_type = media
	disk_size = '120mm'
	for s in out:
		if not manufacturer and 'Manufacturer:' in s:
			try:	manufacturer = s.split('\'')[1]
			except:	pass
		elif not media_id and 'Media type:' in s:
			try:	media_id = s.split('\'')[1]
			except:	pass
		elif 'disc size:' in s:
			try:	disk_size = s.split()[2]
			except:	pass
		#elif 'book type:' in s:
		#	try:	book_type = s.split( None, 2 )[2][:-1]
		#	except:	pass
		elif 'blank:' in s:
			try:	blank = bool( s.split()[3] == '1' )
			except:	pass
	# полный объём диска по-умолчанию
	if disk_size == '120mm':
		if '/DL' in media:
			total_space = 4173824
		else:
			total_space = 2295104
	else:
		if '/DL' in media:
			total_space = 1298828
		else:
			total_space = 714544
	
	appendable = 'DVD+R' in media
		
	if appendable:
		print OK
		exit_flag = False
	else:
		if 'RW' in media:
			err_str = 'need to blank'
			out += [ '.....\n',
				 'You need to blank RW-media.\n',
				 'Try to add -z to the options list.\n',
				 'CAUTION: previous information on disk will be lost\n'	]
		else:	err_str = 'not writable'
		print_error( err_str )
		exit_flag = True

	if blank:
		free_space = total_space
		disk_type += ' (blank)'
	elif appendable:
		cmd = 'isoinfo -d dev=%s 2>&1' % device
		print_debug( cmd )
		flush()
		out, exit_code = run_cmd( cmd )
		used_space = 0
		for s in out:
			if not 'Volume size is:' in s:  continue
			try:	used_space = long( s.split(':')[1] )
			except:	pass
		free_space = total_space - used_space
		disk_type += ' (multisession)'
	else:
		disk_type += ' (fixated)'
	
	if verbose:
		print_key_value( 'Disk', disk_type )
		#print_key_value( 'Book type', book_type )
		print_key_value( 'Physical size', disk_size )
		if media_id:  manufacturer += '/'+media_id
		print_key_value( 'Media ID', manufacturer or 'n/a' )
		if total_space:
			spc = '%.1f MB' % (total_space/(512.0))
			print_key_value( 'Total space', spc )
			spc = '%.1f MB (%u%%)' % ( free_space/(512.0), free_space*100.0/total_space+0.5 )
			print_key_value( 'Free space', spc )
		flush()
	
	if not exit_flag:  return

	if verbose:
		print_prog_out( out )
		flush()
	sys.exit(1)
#}}}

if __name__ == "__main__":	#{{{
	# если stdout - не терминал, выключаем цвет
	if not sys.stdout.isatty():  no_color()

	parse_cmd_line()

	cmd = string.join( sys.argv )
	print_debug( cmd )

	check_programs()
	mkisofs_valid_opts = get_valid_opts( mkisofs_out )
	cdrecord_valid_opts = get_valid_opts( cdrecord_out )
	
	check_disk_in_drive()
	if dvd:
		check_DVD_disk()
	else:	check_CD_disk()

	if info:  sys.exit()

	fnames = []
	for f in filenames:
		f = os.path.abspath( os.path.expanduser( f ) )
		try:	f_stat = os.stat( f )
		except:
			if debug:
				write( '%sNot a file, link or dir. Skipped:  %s\n' % (COLOR_0,f) )
			continue
		mode = f_stat[ stat.ST_MODE ]
		f = escape_str( f )
		basename = os.path.basename( f )
		ok = False
		dir = False
		if stat.S_ISDIR( mode ):
			prefix = root + '/' + basename + '/='
			dir = True
			ok = True
		elif stat.S_ISREG( mode ) or stat.S_ISLNK( mode ):
			prefix = root + '/='
			ok = True
		elif debug:
			write( '%sNot a file, link or dir. Skipped:  %s\n' % (COLOR_0,f) )
			
		if ok:
			if root == '' and not dir:  prefix = ''
			fnames.append( prefix + f )
	flush()
	
	if len(fnames) == 0:
		write( '\n%sNothing to write! Exiting.%s\n' % (COLOR_8,COLOR_0) )
		sys.exit(3)
	
	fnames = string.join( fnames )
	

	write( COLOR_3+'*'+COLOR_0 )
	s = ' Calculating new session size...'
	write( '%s%-50s%s' % (COLOR_1,s,COLOR_0) )
	flush()

	mkisofs_base = \
		'mkisofs -r -J -l -D -joliet-long -allow-leading-dots -allow-lowercase \
		-allow-multidot -graft-points -v'
	if charset != None:
		mkisofs_base += ' -input-charset %s' % ( charset )

	if not blank and not single:
		mkisofs_base += ' -C %lu,%lu -M %s' % ( last_start, new_start, device )
	
	mkisofs_base = filter_opts( mkisofs_base, mkisofs_valid_opts )
	
	mkisofs_print = mkisofs_base + ' -print-size %s 2>&1' % fnames
	mkisofs_cmd = mkisofs_base + ' %s 2>/dev/null' % fnames
	
	cmd = mkisofs_print
	if debug:
		write( '\n%s%s%s\n' % (COLOR_4,cmd,COLOR_0) )
	ch_out = os.popen( cmd )
	out = [ s for s in ch_out ]
	exit_code = ch_out.close()


	mode_str = 'multi session'
	raw_mode = False
	write_single_session = False
	if blank:	multi_overhead = 11702
	else:		multi_overhead = 6902

	if exit_code != None:
		print COLOR_5+'['+COLOR_8+'something wrong'+COLOR_5+']'+COLOR_0
		exit_flag = True
	else:
		try:	new_size = long( out[-1] )
		except:	new_size = 0
		
		delta_size = free_space - new_size
		too_big = False
		exit_flag = False
		
		if dvd:
			if single:
				write_single_session = True
				mode_str = 'single session'
		elif delta_size < multi_overhead:
			if blank:
				write_single_session = True
				mode_str = 'single session'
				multi_overhead = 0
				
				if delta_size < 0:
					if new_size < free_space + 6750:
						raw_mode = True
						mode_str = 'single session, raw'
					else:
						too_big = True
			else:	too_big = True
		
		if too_big:
			print COLOR_5+'['+COLOR_8+'too big'+COLOR_5+']'+COLOR_0
			exit_flag = True
		else:
			print OK
	
	if verbose:
		key_str = 'Session size:'
		try:	sess_size = '%.1f MB (%.1f MB)' % ((new_size+multi_overhead)/512.0,new_size/512.0)
		except:	sess_size = 'n/a'
		write( '  %s%-16s%s%s%s\n'
			% ( COLOR_6, key_str, COLOR_2, sess_size, COLOR_0 ) )
		key_str = 'Burning mode:'
		sess_mode = '%s' % (mode_str)
		write( '  %s%-16s%s%s%s\n'
			% ( COLOR_6, key_str, COLOR_2, sess_mode, COLOR_0 ) )
			
	if exit_flag:
		if verbose:
			write( '  %s.....\n' % COLOR_8 )
			if not debug:  out = out[-10:]
			for s in out:
				write( '  ' + s )
			write( COLOR_0 )
			flush()
		sys.exit(1)
	

	write( COLOR_3+'*'+COLOR_0 )
	s = ' Burning... '
	write( '%s%s' % (COLOR_1,s) )
	flush()
	

	def update_progress_bar( percent, first_pad=0 ):
		bar_len = 53
		write( '\r%s%s[' % (' '*first_pad,COLOR_9) )
		eq_len = int( percent*(bar_len-2) / 100.0 )
		sp_len = bar_len - 2 - eq_len
		write( COLOR_5+ '='*eq_len )
		if 0 < eq_len < bar_len-2:
			write( COLOR_8+ '\b*' )
		write( ' '*sp_len )
		write( COLOR_9+']' )
		flush()

	if write_single_session:
		if raw_mode:
			write_mode = ' -raw -overburn'
		else:	write_mode = ' -dao -overburn'
	else:
		write_mode = ' -tao -multi'

	if speed:  speed_addon = ' speed=%d' % speed
	else:	   speed_addon = ''
	cdrecord_cmd = filter_opts( \
		'cdrecord dev=%s driveropts=burnfree fs=24m gracetime=3 \
		%s -force -v %s -waiti tsize=%lus -immed -eject -' % \
		( device, speed_addon, write_mode, new_size ), cdrecord_valid_opts )
	
	cmd = mkisofs_cmd+' | '+cdrecord_cmd+' 2>&1'
	if debug:
		write( '\n%s%s%s\n' % (COLOR_4,cmd,COLOR_0) )
	ch_out = os.popen( cmd )
	out = []
	while True:
		s = ch_out.readline( 200 )
		if s == '':  break
		out.append( s )
		if 'Starting to write' in s:  break
	b_num = 0
	s = ''
	while True:
		c = ch_out.read(1)
		if c == '':  break
		s += c
		if c == '.':
			if 'Operation starts.' in s:
				write( '\b'*25 + '...' + ' '*22 + '\n' )
				flush()
				update_progress_bar( 0, 2 )
				out.append( s+'\n' )
				break
			elif ' seconds.' in s:
				sec = s.split()[-2]
				write( '\b'*b_num+'(starts in '+COLOR_5+sec+COLOR_0+COLOR_1+' seconds)' )
				flush()
				b_num = 21
				out.append( s+'\n' )
		elif c in '\b\n':
			if len(s) > 1:
				out.append( s[:-1] + '\n' )
			s = ''
	
	avg_speed = 'n/a'
	writing_time = 'n/a'
	fixating_time = 'n/a'
	fixating_flag = False
	s = ''
	while True:
		c = ch_out.read(1)
		if c == '':  break
		s += c
		if c == '\n':
			if 'Fixating...' in s:
				write( '\n' )
				if verbose:
					key_str = 'Average speed:'
					write( '  %s%-16s%s%s%s\n'
						% ( COLOR_6, key_str, COLOR_2, avg_speed, COLOR_0 ) )
					key_str = 'Writing time:'
					write( '  %s%-16s%s%s%s\n'
						% ( COLOR_6, key_str, COLOR_2, writing_time, COLOR_0 ) )
				
				fixating_flag = True
				write( COLOR_3+'*'+COLOR_0 )
				s = ' Fixating...'
				write( '%s%-50s%s' % (COLOR_1,s,COLOR_0) )
				flush()
			elif 'Total bytes read/written:' in s:
				update_progress_bar( 100, 2 )
			elif 'Average write speed' in s:
				try:	avg_speed = s.split()[-1].strip()[:-1]
				except:	pass
			elif 'time:' in s:
				try:
					tmp_time = s.split()[-1].strip()
					if fixating_flag:
						fixating_time = tmp_time
					else:	writing_time = tmp_time
				except:	pass
			out.append( s )
			s = ''

		elif c == '.':
			if (' written ' in s) and ('x.' in s):
				pieces = s.split( None, 5 )
				total = float( pieces[4] )
				written = float( pieces[2] )
				update_progress_bar( written*100/total, 2 )
				out.append( s + '\n' )
				s = ''

		elif c == '\r':
			s = ''
			
	exit_code = ch_out.close()
	
	if exit_code == None:
		print OK
		exit_flag = False
	else:
		print COLOR_5+'['+COLOR_8+'error'+COLOR_5+']'+COLOR_0
		exit_flag = True
	
	if verbose:
		key_str = 'Fixating time:'
		write( '  %s%-16s%s%s%s\n'
			% ( COLOR_6, key_str, COLOR_2, fixating_time, COLOR_0 ) )
			
	if exit_flag:
		if verbose:
			write( '  %s.....\n' % COLOR_8 )
			if not debug:  out = out[-10:]
			for s in out:
				write( '  ' + s )
			write( COLOR_0 )
			flush()
		sys.exit(1)
#}}}
	
# vim:tw=0:ts=8:fdm=marker
