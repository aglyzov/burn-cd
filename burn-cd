#!/usr/bin/python -O
# -*- coding: cp1251 -*-
"""
Краткое описание:	удобная оболочка для cdrtools и dvd+rw-tools
Автор:			SmART
Последнее изменение:	27 ноября 2006

"""
import sys, os, stat, getopt, string, time

# Глобальные переменные {{{
PROG = "burn-cd"

VERSION = \
	"%s version 1.5-alpha2\n" \
	"Written by SmART, 2004-2006\n" % PROG

USAGE = "Usage:  %s [options] <file_or_dir_to_burn> [...]\n" % PROG

DESCRIPTION = \
	"This is handy frontend for cdrtools/cdrkit and dvd+rw-tools\n" \
	"for easy burning of single & multi session CD/DVD disks.\n"

HELP = \
"""Options:
   -r<ROOT>, --root=<ROOT>    destination dir on the CD (defaults to '/')
   -d<DEV>,  --device=<DEV>   CD-RW device (defaults to '/dev/hdc')
   -s<N>,    --speed=<N>      tell cdrecord to burn CD on specific speed
   -c<XYZ>,  --charset=<XYZ>  charset of the filenames (defaults to LOCALE)
   -z,       --zero           blank RW-media before burning (if needed)
   
   -i, --info		      show drive/media info and exit
   -n, --no-color	      disable colors
   -v, --verbose	      show more information during the process
   -h, --help		      show this help and exit
   --version		      show version of the program and exit
   --debug		      enable debug messages during the process
"""
COLOR_0		= "\033[m"
COLOR_1		= "\033[1m"
COLOR_2		= "\033[0;32m"
COLOR_3		= "\033[1;32m"
COLOR_4		= "\033[0;33m"
COLOR_5		= "\033[1;33m"
COLOR_6		= "\033[0;36m"
COLOR_7		= "\033[1;36m"
COLOR_8		= "\033[1;31m"
COLOR_9		= "\033[1;34m"

OK 		= COLOR_9+'['+COLOR_3+'ok'+COLOR_9+']'+COLOR_0
ASTERISK	= COLOR_3+'*'+COLOR_0

mmc_profiles	= {
	0x0000:	'Reserved',
	0x0001:	'Non-removable Disk',
	0x0002:	'Removable Disk',
	0x0003:	'MO Erasable',
	0x0004:	'MO Write Once',
	0x0005:	'AS-MO',
	
	0x0008:	'CD-ROM',
	0x0009:	'CD-R',
	0x000A:	'CD-RW',
	
	0x0010:	'DVD-ROM',
	0x0011:	'DVD-R sequential recording',
	0x0012:	'DVD-RAM',
	0x0013:	'DVD-RW restricted overwrite',
	0x0014:	'DVD-RW sequential overwrite',
	0x0015:	'DVD-R/DL sequential recording',
	0x0016:	'DVD-R/DL layer jump recording',
	
	0x001A:	'DVD+RW',
	0x001B:	'DVD+R',
	
	0x0020:	'DDCD-ROM',
	0x0021:	'DDCD-R',
	0x0022:	'DDCD-RW',
	
	0x002A:	'DVD+RW/DL',
	0x002B:	'DVD+R/DL',
	
	0x0040:	'BD-ROM',
	0x0041:	'BD-R sequential recording',
	0x0042:	'BD-R random recording',
	0x0043:	'BD-RE',
	
	0x0050:	'HD DVD-ROM',
	0x0051:	'HD DVD-R',
	0x0052:	'HD DVD-RAM',

	0xFFFF:	'No standard Profile'
}

disk_capacities	= {
	'80mm DVD-R':		714544,
	'80mm DVD-R/DL':	1298828,
	'80mm DVD-RW':		714544,
	'80mm DVD-RW/DL':	1298828,
	'80mm DVD+R':		714544,
	'80mm DVD+R/DL':	1298828,
	'80mm DVD+RW':		714544,
	'80mm DVD+RW/DL':	1298828,
	'120mm DVD-R':		2295104,
	'120mm DVD-R/DL':	4173824,
	'120mm DVD-RW':		2295104,
	'120mm DVD-RW/DL':	4173824,
	'120mm DVD+R':		2295104,
	'120mm DVD+R/DL':	4173824,
	'120mm DVD+RW':		2295104,
	'120mm DVD+RW/DL':	4173824,
}

write		= sys.stdout.write
flush		= sys.stdout.flush

root		= '/'
lang		= os.getenv( 'LANG' )
try:	charset = lang.split('.')[1].lower()
except:	charset = None
device		= '/dev/hdc'
filenames	= None
fnames		= None
speed		= None 
zero	  	= False
verbose		= False
info		= False
debug		= False
media		= None
blank		= False
single_session	= False
dvd 		= False
free_space	= None
total_space	= None
last_start	= None
new_start	= None
new_size	= None
raw_mode	= None
mkisofs_opts	= None

mkisofs_out	= None
cdrecord_out	= None
isoinfo		= False
growisofs	= False
#}}}

def no_color():	#{{{1
	global	COLOR_0, COLOR_1, COLOR_2, COLOR_3, COLOR_4, \
		COLOR_5, COLOR_6, COLOR_7, COLOR_8, COLOR_9
	
	COLOR_0 = COLOR_1 = COLOR_2 = COLOR_3 = COLOR_4 = \
	COLOR_5 = COLOR_6 = COLOR_7 = COLOR_8 = COLOR_9 = ''
#}}}1
def escape_str( s ):	#{{{1
	s = s.replace( "\"", "\\\"" )
	s = s.replace( "\'", "\\\'" )
	s = s.replace( " ", "\\ " )
	s = s.replace( "=", "\\=" )
	s = s.replace( "(", "\\(" )
	s = s.replace( ")", "\\)" )
	s = s.replace( "[", "\\[" )
	s = s.replace( "]", "\\]" )
	s = s.replace( ";", "\\;" )
	s = s.replace( "&", "\\&" )
	s = s.replace( "|", "\\|" )
	s = s.replace( "\011", "\\\011" )
	s = s.replace( "\012", "\\\012" )
	s = s.replace( "\015", "\\\015" )
	return s
#}}}1
def filter_opts( cmd, valid_opts ):	#{{{
	global debug
	
	cmd = cmd.split()
	new_cmd = []
	for op in cmd:
		if len(op)>1 and op[0] == '-' and op not in valid_opts:
			if debug:
				write( 'stripped:  %s\n' % op )
				flush()
		else:
			new_cmd.append( op )
	return string.join( new_cmd )
#}}}
def get_valid_opts( prog_out ):	#{{{
	valid_opts = []
	for s in prog_out:
		s = s.split( None, 1 )
		if not s:  continue
		s = s[0]
		if s[0] == '-':
			valid_opts += s.split(',')
	return valid_opts
#}}}

def run_cmd( cmd ):	#{{{
	ch_out = os.popen( cmd )
	out = [ s for s in ch_out ]
	exit_code = ch_out.close()

	return out, exit_code
#}}}

def print_debug( s, color=COLOR_4 ):	#{{{
	if not debug:  return
	sys.stdout.write( '%s%s%s\n' % (color, s, COLOR_0) )
#}}}
def print_task( s ):	#{{{
	write( '%s %s%-50s%s' % (ASTERISK, COLOR_1, s, COLOR_0) )
	if debug:  print
#}}}
def print_error( s ):	#{{{
	print COLOR_5+'['+COLOR_8+ s +COLOR_5+']'+COLOR_0
#}}}
def print_key_value( key, val, val_color=COLOR_2 ):	#{{{
	key_str = '%s:' % key
	write(
		'  %s%-16s%s%s%s\n' % \
		( COLOR_6, key_str, val_color, val, COLOR_0 )
	)
#}}}
def print_version( prog, ver ):	#{{{
	if ver:
		val_str = 'version %s' % ver
		val_color = COLOR_2
	else:
		val_str = 'not found'
		val_color = COLOR_4
	print_key_value( prog, val_str, val_color )
#}}}
def print_prog_out( out ):	#{{{
	global debug

	write( '  %s.....\n' % COLOR_8 )
	if not debug:  out = out[-10:]
	for s in out:  write( '  ' + s )
	write( COLOR_0 )
#}}}
def update_progress_bar( percent, first_pad=0 ):	#{{{
	bar_len = 54
	write( '\r%s%s[' % (' '*first_pad,COLOR_9) )
	eq_len = int( percent*(bar_len-2) / 100.0 )
	sp_len = bar_len - 2 - eq_len
	write( COLOR_5+ '='*eq_len )
	if 0 < eq_len < bar_len-2:
		write( COLOR_8+ '\b*' )
	write( ' '*sp_len )
	write( COLOR_9+']' )
	flush()
#}}}

def parse_cmd_line():	#{{{
	global	root, lang, charset, device, speed, zero, \
		verbose, info, debug, media, dvd, filenames

	opts, filenames = [], []
	try:	opts, filenames = getopt.getopt(
			sys.argv[1:], 'vnr:d:hc:is:z',
			[ 'help', 'verbose', 'no-color', 'root=', 'device=',
			  'speed=', 'charset=', 'version', 'info', 'debug',
			  'zero' ]
		)
	except getopt.GetoptError:
		print USAGE
		print DESCRIPTION
		print HELP
		sys.exit(1)
	
	for opt, val in opts:
		if opt in ['-h','--help']:
			print USAGE
			print HELP
			sys.exit(0)
		elif opt in ['--version']:
			print VERSION
			sys.exit(0)
		elif opt in ['-v','--verbose']:
			verbose = True
		elif opt in ['--debug']:
			debug = True
			verbose = True
		elif opt in ['-n','--no_color']:
			no_color()
		elif opt in ['-r','--root']:
			root = val
		elif opt in ['-d','--device']:
			device = val
		elif opt in ['-s','--speed']:
			try:	speed = int(val)
			except:	pass
		elif opt in ['-z','--zero']:
			zero = True
		elif opt in ['-c','--charset']:
			charset = val
		elif opt in ['-i','--info']:
			info = True
			verbose = True
	
	if len(filenames) == 0 and not (info or zero):
		print USAGE
		print DESCRIPTION
		print HELP
		sys.exit(2)
	
	root = '/' + escape_str( root ).lstrip('/')
	root = root.rstrip('/')
#}}}
def check_programs():	#{{{
	global mkisofs_out, cdrecord_out, isoinfo, growisofs, verbose

	print_task('Checking programs...')

	cmd = 'mkisofs -version 2>/dev/null && mkisofs -help 2>&1'
	print_debug( cmd )
	flush()
	mkisofs_out, mkisofs_exit_code = run_cmd( cmd )
	
	cmd = '(cdrecord -version 2>/dev/null | head -n1 ) && cdrecord -help 2>&1'
	print_debug( cmd )
	flush()
	cdrecord_out, cdrecord_exit_code = run_cmd( cmd )
	
	cmd = 'isoinfo -version 2>/dev/null'
	print_debug( cmd )
	flush()
	isoinfo_out, isoinfo_exit_code = run_cmd( cmd )
	
	cmd = 'growisofs -version 2>/dev/null | head -n1'
	print_debug( cmd )
	flush()
	growisofs_out, growisofs_exit_code = run_cmd( cmd )
	
	if mkisofs_exit_code == None and cdrecord_exit_code == None:
		print OK
		exit_flag = False
	else:
		print_error('not found')
		exit_flag = True
	
	# mkisofs
	val_str = None
	if mkisofs_exit_code == None:
		mkisofs_ver = mkisofs_out[0].split(' ',2)[1]
		val_str = mkisofs_ver.split(',',1)[0]
	if verbose:
		print_version( 'mkisofs', val_str )
	
	# cdrecord
	val_str = None
	if cdrecord_exit_code == None:
		val_str = cdrecord_out[0].split(' ',2)[1]
	if verbose:
		print_version( 'cdrecord', val_str )
	
	# isoinfo
	val_str = None
	if isoinfo_exit_code == None:
		val_str = isoinfo_out[0].split(' ',2)[1]
		isoinfo = True
	if verbose:
		print_version( 'isoinfo', val_str )
	
	# growisofs
	val_str = None
	if growisofs_exit_code == None:
		try:
			val_str = growisofs_out[0].split(' ',5)[5]
			val_str = val_str.split(',',1)[0]
			growisofs = True
		except:	pass
	if verbose:
		print_version( 'growisofs', val_str )

	flush()
		
	if not exit_flag:  return

	if verbose:
		out = mkisofs_out + cdrecord_out
		print_prog_out( out )
		flush()
	sys.exit(1)
#}}}
def check_disk_in_drive():	#{{{
	global cdrecord_valid_opts, media, dvd, device, mmc_profiles, verbose

	print_task('Looking for a disk in drive...')

	cmd = filter_opts( 'cdrecord dev=%s -load -silent -v 2>&1' % device, cdrecord_valid_opts )
	print_debug( cmd )
	flush()
	out, exit_code = run_cmd( cmd )
	
	error_str = 'unknown'
	match_wrong_dev = "Cannot open '%s'." % device
	for s in out:
		if match_wrong_dev in s:
			error_str = 'wrong device'
		elif 'Current:' in s:
			media = s.split()[1]
			if mmc_profiles.has_key( media ):
				media = mmc_profiles[ media ]
			if media == 'none':
				media = None
				error_str = 'no disk'
			elif media[:3] == 'DVD':
				dvd = True
	if exit_code == None:
		print OK
		exit_flag = False
	else:
		print_error( error_str )
		exit_flag = True
	flush()
	
	if verbose:
		print_key_value( 'Device', device )
		for s in out:
			if 'Vendor_info' in s:
				try:
					val_str = s.split( '\'', 2 )[1].strip()
					print_key_value( 'Vendor', val_str )
				except:	pass
			if 'Identifi' in s:
				try:
					val_str = s.split( '\'', 2 )[1].strip()
					print_key_value( 'Model', val_str )
				except:	pass
			if 'Revision' in s:
				try:
					val_str = s.split( '\'', 2 )[1].strip()
					print_key_value( 'Firmware', val_str )
				except:	pass
			if 'Device seems to be' in s:
				try:
					val_str = s.split( ':', 1 )[1].strip()[:-1]
					print_key_value( 'Type', val_str )
				except:	pass
		flush()
	
	if not exit_flag:  return

	if verbose:
		print_prog_out( out )
		flush()
	sys.exit(1)
#}}}
def check_cd_disk():	#{{{
	global	media, device, cdrecord_valid_opts, verbose, last_start, \
		new_start, blank, free_space, total_space

	print_task( 'Checking disk type...' )

	cmd = filter_opts(
		'cdrecord dev=%s -msinfo -silent -v 2>&1' % device,
		cdrecord_valid_opts
	)
	print_debug( cmd )
	flush()
	out, exit_code = run_cmd( cmd )

	appendable = True
	blank = False
	last_start = new_start = 0
	total_space = free_space = 0
	manufacturer = 'n/a'
	disk_type = media
	atip = False
	max_speed = 0
	for s in out:
		if 'ATIP info from disk' in s:
			atip = True
		elif 'ATIP start of lead out' in s:
			try:	total_space = long( s.split(':',1)[1].strip().split()[0] )
			except:	pass
		elif 'Manufacturer' in s:
			try:	manufacturer = s.split(':',1)[1].strip()
			except:	pass
		elif 'Cannot read session offset' in s:
			blank = True
		elif 'Cannot read first writable address' in s:
			appendable = False
		elif '1T speed high:' in s:
			try:	max_speed = int( s.split()[-1].strip() )
			except:	pass
		
	if appendable:
		print OK
		exit_flag = False
	else:
		if 'RW' in media:
			err_str = 'need to blank'
			out += [ '.....\n',
				 'You need to blank RW-media. Add -z to the options list.\n',
				 'CAUTION: any previous information on disk will be lost\n' ]
		else:	err_str = 'not writable'
		print_error( err_str )
		exit_flag = True
	flush()

	if blank:
		free_space = total_space
		disk_type += ' (blank)'
	elif appendable:
		s = out[-1]
		try:	last_start, new_start = map( long, s.split(',',1) )
		except:	pass
		free_space = total_space - new_start
		disk_type += ' (multisession)'
	elif atip:
		disk_type += ' (finalized)'
	
	if verbose:
		print_key_value( 'Disk', disk_type )
		print_key_value( 'Manufacturer', manufacturer )
		if max_speed:
			print_key_value( 'Maximum speed', max_speed )
		if total_space:
			spc = '%.1f MB' % (total_space/512.0)
			print_key_value( 'Total space', spc )
			spc = '%.1f MB (%u%%)' % ( free_space/512.0, free_space*100.0/total_space+0.5 )
			print_key_value( 'Free space', spc )
		flush()
	
	if not exit_flag:  return

	if verbose:
		print_prog_out( out )
		flush()
	sys.exit(1)
#}}}
def check_dvd_disk():	#{{{
	global	media, device, cdrecord_valid_opts, disk_capacities, verbose, \
		zero, blank, isoinfo, free_space, total_space

	print_task( 'Checking disk type...' )

	cmd = filter_opts(
		'cdrecord dev=%s -atip -silent -v 2>&1' % device,
		cdrecord_valid_opts
	)
	print_debug( cmd )
	flush()
	out, exit_code = run_cmd( cmd )

	blank = False
	total_space = free_space = 0
	manufacturer = None
	media_id = None
	disk_type = media
	disk_size = '120mm'
	for s in out:
		if not manufacturer and 'Manufacturer:' in s:
			try:	manufacturer = s.split('\'')[1]
			except:	pass
		elif not media_id and 'Media type:' in s:
			try:	media_id = s.split('\'')[1]
			except:	pass
		elif 'disc size:' in s:
			try:	disk_size = s.split()[2]
			except:	pass
		elif 'blank:' in s:
			try:	blank = bool( s.split()[3] == '1' )
			except:	pass
	# объём диска по-умолчанию
	d = disk_size + ' ' + media.split( None, 1 )[0]
	total_space = disk_capacities[ d ]
	
	appendable = True
	if 'ROM' in media:
		appendable = False
	
	if zero and 'RW' in media:
		blank = True
		appendable = True
		
	if appendable:
		print OK
		exit_flag = False
	else:
		#if 'RW' in media:
		#	err_str = 'need to blank'
		#	out += [ '.....\n',
		#		 'You need to blank RW-media. Add -z to the options list.\n',
		#		 'CAUTION: any previous information on disk will be lost\n'	]
		#else:	err_str = 'not writable'
		err_str = 'not writable'
		print_error( err_str )
		exit_flag = True
	flush()

	if blank:
		free_space = total_space
		disk_type += ' (blank)'
	elif appendable:
		cmd = 'isoinfo -d dev=%s 2>&1' % device
		print_debug( cmd )
		flush()
		if isoinfo:
			out, exit_code = run_cmd( cmd )
		else:	out = []
		used_space = 0
		for s in out:
			if not 'Volume size is:' in s:  continue
			try:	used_space = long( s.split(':')[1] )
			except:	pass
		free_space = total_space - used_space
		disk_type += ' (multisession)'
	else:
		disk_type += ' (complete)'
	
	if verbose:
		print_key_value( 'Disk', disk_type )
		print_key_value( 'Physical size', disk_size )
		if media_id:  manufacturer += '/'+media_id
		print_key_value( 'Media ID', manufacturer or 'n/a' )
		if total_space:
			spc = '%.1f MB' % (total_space/(512.0))
			print_key_value( 'Total space', spc )
			spc = '%.1f MB (%u%%)' % ( free_space/(512.0), free_space*100.0/total_space+0.5 )
			print_key_value( 'Free space', spc )
		flush()
	
	if not exit_flag:  return

	if verbose:
		print_prog_out( out )
		flush()
	sys.exit(1)
#}}}
def build_file_list():	#{{{
	global filenames, fnames, debug

	os_basename = os.path.basename
	S_ISDIR = stat.S_ISDIR
	S_ISREG = stat.S_ISREG
	S_ISLNK = stat.S_ISLNK
	ST_MODE = stat.ST_MODE

	fnames = []
	for f in filenames:
		f = os.path.abspath( os.path.expanduser( f ) )
		try:	f_stat = os.stat( f )
		except:
			print_debug( 'Not a file, link or dir. Skipped:  %s' % f )
			continue
		mode = f_stat[ ST_MODE ]
		f = escape_str( f )
		basename = os_basename( f )
		ok = False
		dir_flag = False
		if S_ISDIR( mode ):
			prefix = root + '/' + basename + '/='
			dir_flag = True
			ok = True
		elif S_ISREG( mode ) or S_ISLNK( mode ):
			prefix = root + '/='
			ok = True
		else:
			print_debug( 'Not a file, link or dir. Skipped:  %s' % f )
			
		if ok:
			if root == '' and not dir_flag:  prefix = ''
			fnames.append( prefix + f )
	flush()
	
	if len(fnames) == 0:
		write( '%sNothing to write! Exiting.%s\n' % (COLOR_4,COLOR_0) )
		sys.exit(3)
	
	fnames = string.join( fnames )
#}}}
def blank_cdrw():	#{{{
	global blank, device
	blank = True

	write( '%s*%s %sBlanking CD-RW... ' % (COLOR_3, COLOR_0, COLOR_1) )
	flush()

	cmd = 'cdrecord blank=fast gracetime=3 dev=%s -force -v 2>&1' % device
	print_debug( cmd )
	
	ch_out = os.popen( cmd )
	out = []
	while True:
		s = ch_out.readline( 200 )
		if s == '':  break
		out.append( s )
		if 'Starting to write' in s:  break
	b_num = 0
	s = ''
	while True:
		c = ch_out.read(1)
		if c == '':  break
		s += c
		if c == '.':
			if 'Operation starts.' in s:
				write( '\b'*b_num + ' '*32 )
				flush()
				out.append( s+'\n' )
				break
			elif ' seconds.' in s:
				sec = s.split()[-2]
				write( '\b'*b_num+'(starts in '+COLOR_5+sec+COLOR_0+COLOR_1+' seconds)' )
				flush()
				b_num = 21
				out.append( s+'\n' )
		elif c in '\b\n':
			if len(s) > 1:
				out.append( s[:-1] + '\n' )
			s = ''
	blank_time = None
	while True:
		s = ch_out.readline( 200 )
		if s == '':  break
		out.append( s )
		if 'Blanking time:' in s:
			try:
				last_item = s.split()[-1].strip()
				t = float( last_item[:-1] )
				blank_time = '%u sec' % round( t )
			except:	pass
	exit_code = ch_out.close()
	
	if exit_code == None:
		print OK
		exit_flag = False
		if verbose:  print_key_value( 'Blanking time', blank_time or 'n/a' )
	else:
		print_error( 'error' )
		exit_flag = True
	flush()
			
	if not exit_flag:  return

	if verbose:
		print_prog_out( out )
		flush()
	sys.exit(1)
#}}}
def check_new_session():	#{{{
	global	verbose, charset, last_start, new_start, device, \
		mkisofs_valid_opts, free_space, zero, \
		mkisofs_opts, raw_mode, single_session, new_size

	print_task( 'Calculating new session size...' )
	flush()

	mkisofs_base = '-r -J -joliet-long -D -U -graft-points -f'
	if charset != None:
		mkisofs_base += ' -input-charset %s' % ( charset )

	if not blank and not dvd:
		mkisofs_base += ' -C %lu,%lu -M %s' % ( last_start, new_start, device )
	
	mkisofs_base = filter_opts( mkisofs_base, mkisofs_valid_opts )
	
	mkisofs_opts = '%s %s' % (mkisofs_base, fnames)
	mkisofs_print = 'mkisofs %s -print-size %s 2>&1' % (mkisofs_base, fnames)

	cmd = mkisofs_print
	print_debug( cmd )
	flush()
	
	ch_out, exit_code = run_cmd( cmd )

	raw_mode = False
	single_session = False
	if blank:
		multi_overhead = 11702
		mode_str = 'start multi-session'
	else:
		mode_str = 'continue multi-session'
		multi_overhead = 6902

	if exit_code != None:
		print_error( 'something wrong' )
		exit_flag = True
	else:
		try:	new_size = long( ch_out[-1] )
		except:	new_size = 0
		
		delta_size = free_space - new_size
		too_big = False
		exit_flag = False
		
		if delta_size < multi_overhead:
			if not dvd and blank:
				single_session = True
				mode_str = 'single session'
				multi_overhead = 0
				
				if delta_size < 0:
					if new_size < free_space + 6750:
						raw_mode = True
						mode_str = 'single session, raw'
					else:
						too_big = True
			else:	too_big = True
		if too_big:
			print_error( 'too big' )
			exit_flag = True
		else:
			print OK
	
	if verbose:
		try:	sess_size = '%.1f MB (%.1f MB)' % ((new_size+multi_overhead)/512.0,new_size/512.0)
		except:	sess_size = 'n/a'
		print_key_value( 'Session size', sess_size )
		print_key_value( 'Burning mode', mode_str )
	flush()
			
	if not exit_flag:  return

	if verbose:
		print_prog_out( ch_out )
		flush()
	sys.exit(1)
#}}}
def burn_cd_disk():	#{{{
	global	single_session, raw_mode, speed, new_size, cdrecord_valid_opts, \
		device, mkisofs_opts

	write( '%s*%s %sBurning... ' % (COLOR_3, COLOR_0, COLOR_1) )
	flush()

	if single_session:
		if raw_mode:
			write_mode = ' -raw -overburn'
		else:	write_mode = ' -dao -overburn'
	else:
		write_mode = ' -tao -multi'

	if speed:  speed_addon = ' speed=%d' % speed
	else:	   speed_addon = ''
	cdrecord_cmd = filter_opts( \
		'cdrecord dev=%s driveropts=burnfree fs=24m gracetime=3 \
		%s -force -v %s -waiti tsize=%lus -immed -eject -' % \
		(device, speed_addon, write_mode, new_size), cdrecord_valid_opts )
	
	cmd = 'mkisofs %s 2>/dev/null | %s 2>&1' % (mkisofs_opts, cdrecord_cmd) 
	print_debug( cmd )

	ch_out = os.popen( cmd )
	out = []
	while True:
		s = ch_out.readline( 200 )
		if s == '':  break
		out.append( s )
		if 'Starting to write' in s:  break
	b_num = 0
	s = ''
	while True:
		c = ch_out.read(1)
		if c == '':  break
		s += c
		if c == '.':
			if 'Operation starts.' in s:
				write( '\b'*25 + '...' + ' '*22 + '\n' )
				flush()
				update_progress_bar( 0, 2 )
				out.append( s+'\n' )
				break
			elif ' seconds.' in s:
				sec = s.split()[-2]
				write( '\b'*b_num+'(starts in '+COLOR_5+sec+COLOR_0+COLOR_1+' seconds)' )
				flush()
				b_num = 21
				out.append( s+'\n' )
		elif c in '\b\n':
			if len(s) > 1:
				out.append( s[:-1] + '\n' )
			s = ''
	
	avg_speed = 'n/a'
	writing_time = 'n/a'
	fixating_time = 'n/a'
	fixating_flag = False
	s = ''
	while True:
		c = ch_out.read(1)
		if c == '':  break
		s += c
		if c == '\n':
			if 'Fixating...' in s:
				write( '\n' )
				if verbose:
					print_key_value( 'Average speed', avg_speed )
					print_key_value( 'Writing time', writing_time )
				fixating_flag = True
				print_task( 'Fixating...' )
				flush()
			elif 'Total bytes read/written:' in s:
				update_progress_bar( 100, 2 )
			elif 'Average write speed' in s:
				try:	avg_speed = s.split()[-1].strip()[:-1]
				except:	pass
			elif 'time:' in s:
				try:
					tmp_time = s.split()[-1].strip()
					if fixating_flag:
						fixating_time = tmp_time
					else:	writing_time = tmp_time
				except:	pass
			out.append( s )
			s = ''
		elif c == '.':
			if (' written ' in s) and ('x.' in s):
				pieces = s.split( None, 5 )
				total = float( pieces[4] )
				written = float( pieces[2] )
				update_progress_bar( written*100/total, 2 )
				out.append( s + '\n' )
				s = ''
		elif c == '\r':
			s = ''
	exit_code = ch_out.close()
	
	if exit_code == None:
		print OK
		exit_flag = False
		if verbose:  print_key_value( 'Fixating time', fixating_time )
	else:
		print_error( 'error' )
		exit_flag = True
	flush()
			
	if not exit_flag:  return

	if verbose:
		print_prog_out( out )
		flush()
	sys.exit(1)
#}}}
def burn_dvd_disk():	#{{{
	global	speed, device, mkisofs_opts, blank, growisofs, new_size

	write( '%s*%s %sBurning... ' % (COLOR_3, COLOR_0, COLOR_1) )
	flush()

	if not growisofs:
		print_error('no growisofs')
		if verbose:
			out = ['Program growisofs not found']
			print_prog_out( out )
			flush()
		sys.exit(1)

	base = 'growisofs -use-the-force-luke=tty'
	if speed:  base += ' -speed=%u' % speed
	if blank:
		base += ' -Z %s' % device
	else:	base += ' -M %s' % device
		
	cmd = '%s %s 2>&1' % ( base, mkisofs_opts )
	print_debug( cmd )

	b_num = 0
	for c in ('3','2','1'):
		write( '\b'*b_num+'(starts in '+COLOR_5+c+COLOR_0+COLOR_1+' seconds)' )
		flush()
		b_num = 21 
		time.sleep(1)
	write( '\b'*b_num+' '*b_num+'\n' )
	update_progress_bar( 0, 2 )

	ch_out = os.popen( cmd )
	out = []
	avg_speed = None
	writing_start = time.time()
	leadout_start = None
	while True:
		s = ch_out.readline(200)
		if s == '':  break
		out.append( s )
		if '% done,' in s:
			try:	p = float( s.split('%',1)[0] )
			except:	pass
			update_progress_bar( p, 2 )
		if 'writing lead-out' in s:
			print_task( 'Writing lead-out...' )
			flush()
			leadout_start = time.time()
		elif 'extents written' in s:
			update_progress_bar( 100, 2 )
			write( '\n' )
			if verbose:
				t = time.time()-writing_start
				speed = new_size*2 / t
				coef = speed / 1352
				avg_speed = '%.1fx (%.1f MB/s)' % ( coef, speed/1024 )
				print_key_value( 'Average speed', avg_speed )
				writing_time = '%d sec' % round( t )
				print_key_value( 'Writing time', writing_time )
			flush()
		#elif 'out @ average' in s:
		#	try:
		#		last_item = s.split()[-1]
		#		coef = float( last_item.split('x',1)[0] )
		#		speed = coef * 1352 / 1024
		#	except:	avg_speed = 'FAST :)'
	exit_code = ch_out.close()
	
	if exit_code == None:
		print OK
		exit_flag = False
		if verbose:
			leadout_time = '%d sec' % round( time.time()-leadout_start )
			print_key_value( 'Lead-out time', leadout_time or 'n/a' )
		flush()
		ej_out, ej_excode = run_cmd( 'cdrecord dev=%s -eject 2>/dev/null' % device )
	else:
		print_error( 'error' )
		exit_flag = True
	flush()
			
	# DEBUG
	#for s in out:
	#	print( s[:-1] )
	if not exit_flag:  return

	if verbose:
		print_prog_out( out )
		flush()
	sys.exit(1)
#}}}

if __name__ == "__main__":	#{{{
	# если stdout - не терминал, выключаем цвет
	if not sys.stdout.isatty():  no_color()

	parse_cmd_line()

	cmd = string.join( sys.argv )
	print_debug( cmd )

	check_programs()
	mkisofs_valid_opts = get_valid_opts( mkisofs_out )
	cdrecord_valid_opts = get_valid_opts( cdrecord_out )
	
	check_disk_in_drive()
	if dvd:
		check_dvd_disk()
	else:	check_cd_disk()

	if info:  sys.exit()

	if zero and not dvd:  blank_cdrw()

	build_file_list()
	check_new_session()
	
	if dvd:
		burn_dvd_disk()
	else:	burn_cd_disk()
#}}}
	
# vim:tw=0:ts=8:fdm=marker
